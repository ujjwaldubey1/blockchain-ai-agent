"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcWebImpl = exports.QueryParamsDesc = exports.QueryAggregateVotesDesc = exports.QueryAggregateVoteDesc = exports.QueryAggregatePrevotesDesc = exports.QueryAggregatePrevoteDesc = exports.QueryMissCounterDesc = exports.QueryFeederDelegationDesc = exports.QueryVoteTargetsDesc = exports.QueryActivesDesc = exports.QueryTobinTaxesDesc = exports.QueryTobinTaxDesc = exports.QueryExchangeRatesDesc = exports.QueryExchangeRateDesc = exports.QueryDesc = exports.QueryClientImpl = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryAggregateVotesResponse = exports.QueryAggregateVotesRequest = exports.QueryAggregateVoteResponse = exports.QueryAggregateVoteRequest = exports.QueryAggregatePrevotesResponse = exports.QueryAggregatePrevotesRequest = exports.QueryAggregatePrevoteResponse = exports.QueryAggregatePrevoteRequest = exports.QueryMissCounterResponse = exports.QueryMissCounterRequest = exports.QueryFeederDelegationResponse = exports.QueryFeederDelegationRequest = exports.QueryVoteTargetsResponse = exports.QueryVoteTargetsRequest = exports.QueryActivesResponse = exports.QueryActivesRequest = exports.QueryTobinTaxesResponse = exports.QueryTobinTaxesRequest = exports.QueryTobinTaxResponse = exports.QueryTobinTaxRequest = exports.QueryExchangeRatesResponse = exports.QueryExchangeRatesRequest = exports.QueryExchangeRateResponse = exports.QueryExchangeRateRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const grpc_web_1 = require("@improbable-eng/grpc-web");
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const oracle_1 = require("../../../terra/oracle/v1beta1/oracle");
const browser_headers_1 = require("browser-headers");
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
exports.protobufPackage = "terra.oracle.v1beta1";
const baseQueryExchangeRateRequest = { denom: "" };
exports.QueryExchangeRateRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryExchangeRateRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryExchangeRateRequest);
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = String(object.denom);
        }
        else {
            message.denom = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryExchangeRateRequest);
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = object.denom;
        }
        else {
            message.denom = "";
        }
        return message;
    },
};
const baseQueryExchangeRateResponse = { exchangeRate: "" };
exports.QueryExchangeRateResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exchangeRate !== "") {
            writer.uint32(10).string(message.exchangeRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryExchangeRateResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exchangeRate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryExchangeRateResponse);
        if (object.exchangeRate !== undefined && object.exchangeRate !== null) {
            message.exchangeRate = String(object.exchangeRate);
        }
        else {
            message.exchangeRate = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.exchangeRate !== undefined && (obj.exchangeRate = message.exchangeRate);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryExchangeRateResponse);
        if (object.exchangeRate !== undefined && object.exchangeRate !== null) {
            message.exchangeRate = object.exchangeRate;
        }
        else {
            message.exchangeRate = "";
        }
        return message;
    },
};
const baseQueryExchangeRatesRequest = {};
exports.QueryExchangeRatesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryExchangeRatesRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryExchangeRatesRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryExchangeRatesRequest);
        return message;
    },
};
const baseQueryExchangeRatesResponse = {};
exports.QueryExchangeRatesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.exchangeRates) {
            coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryExchangeRatesResponse);
        message.exchangeRates = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exchangeRates.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryExchangeRatesResponse);
        message.exchangeRates = [];
        if (object.exchangeRates !== undefined && object.exchangeRates !== null) {
            for (const e of object.exchangeRates) {
                message.exchangeRates.push(coin_1.DecCoin.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.exchangeRates) {
            obj.exchangeRates = message.exchangeRates.map((e) => (e ? coin_1.DecCoin.toJSON(e) : undefined));
        }
        else {
            obj.exchangeRates = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryExchangeRatesResponse);
        message.exchangeRates = [];
        if (object.exchangeRates !== undefined && object.exchangeRates !== null) {
            for (const e of object.exchangeRates) {
                message.exchangeRates.push(coin_1.DecCoin.fromPartial(e));
            }
        }
        return message;
    },
};
const baseQueryTobinTaxRequest = { denom: "" };
exports.QueryTobinTaxRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTobinTaxRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryTobinTaxRequest);
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = String(object.denom);
        }
        else {
            message.denom = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryTobinTaxRequest);
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = object.denom;
        }
        else {
            message.denom = "";
        }
        return message;
    },
};
const baseQueryTobinTaxResponse = { tobinTax: "" };
exports.QueryTobinTaxResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tobinTax !== "") {
            writer.uint32(10).string(message.tobinTax);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTobinTaxResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tobinTax = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryTobinTaxResponse);
        if (object.tobinTax !== undefined && object.tobinTax !== null) {
            message.tobinTax = String(object.tobinTax);
        }
        else {
            message.tobinTax = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.tobinTax !== undefined && (obj.tobinTax = message.tobinTax);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryTobinTaxResponse);
        if (object.tobinTax !== undefined && object.tobinTax !== null) {
            message.tobinTax = object.tobinTax;
        }
        else {
            message.tobinTax = "";
        }
        return message;
    },
};
const baseQueryTobinTaxesRequest = {};
exports.QueryTobinTaxesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTobinTaxesRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryTobinTaxesRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryTobinTaxesRequest);
        return message;
    },
};
const baseQueryTobinTaxesResponse = {};
exports.QueryTobinTaxesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.tobinTaxes) {
            oracle_1.Denom.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTobinTaxesResponse);
        message.tobinTaxes = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tobinTaxes.push(oracle_1.Denom.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryTobinTaxesResponse);
        message.tobinTaxes = [];
        if (object.tobinTaxes !== undefined && object.tobinTaxes !== null) {
            for (const e of object.tobinTaxes) {
                message.tobinTaxes.push(oracle_1.Denom.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.tobinTaxes) {
            obj.tobinTaxes = message.tobinTaxes.map((e) => (e ? oracle_1.Denom.toJSON(e) : undefined));
        }
        else {
            obj.tobinTaxes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryTobinTaxesResponse);
        message.tobinTaxes = [];
        if (object.tobinTaxes !== undefined && object.tobinTaxes !== null) {
            for (const e of object.tobinTaxes) {
                message.tobinTaxes.push(oracle_1.Denom.fromPartial(e));
            }
        }
        return message;
    },
};
const baseQueryActivesRequest = {};
exports.QueryActivesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryActivesRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryActivesRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryActivesRequest);
        return message;
    },
};
const baseQueryActivesResponse = { actives: "" };
exports.QueryActivesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.actives) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryActivesResponse);
        message.actives = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actives.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryActivesResponse);
        message.actives = [];
        if (object.actives !== undefined && object.actives !== null) {
            for (const e of object.actives) {
                message.actives.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.actives) {
            obj.actives = message.actives.map((e) => e);
        }
        else {
            obj.actives = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryActivesResponse);
        message.actives = [];
        if (object.actives !== undefined && object.actives !== null) {
            for (const e of object.actives) {
                message.actives.push(e);
            }
        }
        return message;
    },
};
const baseQueryVoteTargetsRequest = {};
exports.QueryVoteTargetsRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryVoteTargetsRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryVoteTargetsRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryVoteTargetsRequest);
        return message;
    },
};
const baseQueryVoteTargetsResponse = { voteTargets: "" };
exports.QueryVoteTargetsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.voteTargets) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryVoteTargetsResponse);
        message.voteTargets = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.voteTargets.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryVoteTargetsResponse);
        message.voteTargets = [];
        if (object.voteTargets !== undefined && object.voteTargets !== null) {
            for (const e of object.voteTargets) {
                message.voteTargets.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.voteTargets) {
            obj.voteTargets = message.voteTargets.map((e) => e);
        }
        else {
            obj.voteTargets = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryVoteTargetsResponse);
        message.voteTargets = [];
        if (object.voteTargets !== undefined && object.voteTargets !== null) {
            for (const e of object.voteTargets) {
                message.voteTargets.push(e);
            }
        }
        return message;
    },
};
const baseQueryFeederDelegationRequest = { validatorAddr: "" };
exports.QueryFeederDelegationRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryFeederDelegationRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryFeederDelegationRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = String(object.validatorAddr);
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryFeederDelegationRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = object.validatorAddr;
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
};
const baseQueryFeederDelegationResponse = { feederAddr: "" };
exports.QueryFeederDelegationResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.feederAddr !== "") {
            writer.uint32(10).string(message.feederAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryFeederDelegationResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.feederAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryFeederDelegationResponse);
        if (object.feederAddr !== undefined && object.feederAddr !== null) {
            message.feederAddr = String(object.feederAddr);
        }
        else {
            message.feederAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.feederAddr !== undefined && (obj.feederAddr = message.feederAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryFeederDelegationResponse);
        if (object.feederAddr !== undefined && object.feederAddr !== null) {
            message.feederAddr = object.feederAddr;
        }
        else {
            message.feederAddr = "";
        }
        return message;
    },
};
const baseQueryMissCounterRequest = { validatorAddr: "" };
exports.QueryMissCounterRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryMissCounterRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryMissCounterRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = String(object.validatorAddr);
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryMissCounterRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = object.validatorAddr;
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
};
const baseQueryMissCounterResponse = { missCounter: long_1.default.UZERO };
exports.QueryMissCounterResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.missCounter.isZero()) {
            writer.uint32(8).uint64(message.missCounter);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryMissCounterResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.missCounter = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryMissCounterResponse);
        if (object.missCounter !== undefined && object.missCounter !== null) {
            message.missCounter = long_1.default.fromString(object.missCounter);
        }
        else {
            message.missCounter = long_1.default.UZERO;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.missCounter !== undefined && (obj.missCounter = (message.missCounter || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryMissCounterResponse);
        if (object.missCounter !== undefined && object.missCounter !== null) {
            message.missCounter = object.missCounter;
        }
        else {
            message.missCounter = long_1.default.UZERO;
        }
        return message;
    },
};
const baseQueryAggregatePrevoteRequest = { validatorAddr: "" };
exports.QueryAggregatePrevoteRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregatePrevoteRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregatePrevoteRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = String(object.validatorAddr);
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregatePrevoteRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = object.validatorAddr;
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
};
const baseQueryAggregatePrevoteResponse = {};
exports.QueryAggregatePrevoteResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.aggregatePrevote !== undefined) {
            oracle_1.AggregateExchangeRatePrevote.encode(message.aggregatePrevote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregatePrevoteResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.aggregatePrevote = oracle_1.AggregateExchangeRatePrevote.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregatePrevoteResponse);
        if (object.aggregatePrevote !== undefined && object.aggregatePrevote !== null) {
            message.aggregatePrevote = oracle_1.AggregateExchangeRatePrevote.fromJSON(object.aggregatePrevote);
        }
        else {
            message.aggregatePrevote = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.aggregatePrevote !== undefined &&
            (obj.aggregatePrevote = message.aggregatePrevote
                ? oracle_1.AggregateExchangeRatePrevote.toJSON(message.aggregatePrevote)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregatePrevoteResponse);
        if (object.aggregatePrevote !== undefined && object.aggregatePrevote !== null) {
            message.aggregatePrevote = oracle_1.AggregateExchangeRatePrevote.fromPartial(object.aggregatePrevote);
        }
        else {
            message.aggregatePrevote = undefined;
        }
        return message;
    },
};
const baseQueryAggregatePrevotesRequest = {};
exports.QueryAggregatePrevotesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregatePrevotesRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryAggregatePrevotesRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryAggregatePrevotesRequest);
        return message;
    },
};
const baseQueryAggregatePrevotesResponse = {};
exports.QueryAggregatePrevotesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.aggregatePrevotes) {
            oracle_1.AggregateExchangeRatePrevote.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregatePrevotesResponse);
        message.aggregatePrevotes = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.aggregatePrevotes.push(oracle_1.AggregateExchangeRatePrevote.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregatePrevotesResponse);
        message.aggregatePrevotes = [];
        if (object.aggregatePrevotes !== undefined && object.aggregatePrevotes !== null) {
            for (const e of object.aggregatePrevotes) {
                message.aggregatePrevotes.push(oracle_1.AggregateExchangeRatePrevote.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.aggregatePrevotes) {
            obj.aggregatePrevotes = message.aggregatePrevotes.map((e) => e ? oracle_1.AggregateExchangeRatePrevote.toJSON(e) : undefined);
        }
        else {
            obj.aggregatePrevotes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregatePrevotesResponse);
        message.aggregatePrevotes = [];
        if (object.aggregatePrevotes !== undefined && object.aggregatePrevotes !== null) {
            for (const e of object.aggregatePrevotes) {
                message.aggregatePrevotes.push(oracle_1.AggregateExchangeRatePrevote.fromPartial(e));
            }
        }
        return message;
    },
};
const baseQueryAggregateVoteRequest = { validatorAddr: "" };
exports.QueryAggregateVoteRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregateVoteRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregateVoteRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = String(object.validatorAddr);
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregateVoteRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = object.validatorAddr;
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
};
const baseQueryAggregateVoteResponse = {};
exports.QueryAggregateVoteResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.aggregateVote !== undefined) {
            oracle_1.AggregateExchangeRateVote.encode(message.aggregateVote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregateVoteResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.aggregateVote = oracle_1.AggregateExchangeRateVote.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregateVoteResponse);
        if (object.aggregateVote !== undefined && object.aggregateVote !== null) {
            message.aggregateVote = oracle_1.AggregateExchangeRateVote.fromJSON(object.aggregateVote);
        }
        else {
            message.aggregateVote = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.aggregateVote !== undefined &&
            (obj.aggregateVote = message.aggregateVote
                ? oracle_1.AggregateExchangeRateVote.toJSON(message.aggregateVote)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregateVoteResponse);
        if (object.aggregateVote !== undefined && object.aggregateVote !== null) {
            message.aggregateVote = oracle_1.AggregateExchangeRateVote.fromPartial(object.aggregateVote);
        }
        else {
            message.aggregateVote = undefined;
        }
        return message;
    },
};
const baseQueryAggregateVotesRequest = {};
exports.QueryAggregateVotesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregateVotesRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryAggregateVotesRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryAggregateVotesRequest);
        return message;
    },
};
const baseQueryAggregateVotesResponse = {};
exports.QueryAggregateVotesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.aggregateVotes) {
            oracle_1.AggregateExchangeRateVote.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregateVotesResponse);
        message.aggregateVotes = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.aggregateVotes.push(oracle_1.AggregateExchangeRateVote.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregateVotesResponse);
        message.aggregateVotes = [];
        if (object.aggregateVotes !== undefined && object.aggregateVotes !== null) {
            for (const e of object.aggregateVotes) {
                message.aggregateVotes.push(oracle_1.AggregateExchangeRateVote.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.aggregateVotes) {
            obj.aggregateVotes = message.aggregateVotes.map((e) => e ? oracle_1.AggregateExchangeRateVote.toJSON(e) : undefined);
        }
        else {
            obj.aggregateVotes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregateVotesResponse);
        message.aggregateVotes = [];
        if (object.aggregateVotes !== undefined && object.aggregateVotes !== null) {
            for (const e of object.aggregateVotes) {
                message.aggregateVotes.push(oracle_1.AggregateExchangeRateVote.fromPartial(e));
            }
        }
        return message;
    },
};
const baseQueryParamsRequest = {};
exports.QueryParamsRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
    },
};
const baseQueryParamsResponse = {};
exports.QueryParamsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== undefined) {
            oracle_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.params = oracle_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        if (object.params !== undefined && object.params !== null) {
            message.params = oracle_1.Params.fromJSON(object.params);
        }
        else {
            message.params = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? oracle_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        if (object.params !== undefined && object.params !== null) {
            message.params = oracle_1.Params.fromPartial(object.params);
        }
        else {
            message.params = undefined;
        }
        return message;
    },
};
class QueryClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.ExchangeRate = this.ExchangeRate.bind(this);
        this.ExchangeRates = this.ExchangeRates.bind(this);
        this.TobinTax = this.TobinTax.bind(this);
        this.TobinTaxes = this.TobinTaxes.bind(this);
        this.Actives = this.Actives.bind(this);
        this.VoteTargets = this.VoteTargets.bind(this);
        this.FeederDelegation = this.FeederDelegation.bind(this);
        this.MissCounter = this.MissCounter.bind(this);
        this.AggregatePrevote = this.AggregatePrevote.bind(this);
        this.AggregatePrevotes = this.AggregatePrevotes.bind(this);
        this.AggregateVote = this.AggregateVote.bind(this);
        this.AggregateVotes = this.AggregateVotes.bind(this);
        this.Params = this.Params.bind(this);
    }
    ExchangeRate(request, metadata) {
        return this.rpc.unary(exports.QueryExchangeRateDesc, exports.QueryExchangeRateRequest.fromPartial(request), metadata);
    }
    ExchangeRates(request, metadata) {
        return this.rpc.unary(exports.QueryExchangeRatesDesc, exports.QueryExchangeRatesRequest.fromPartial(request), metadata);
    }
    TobinTax(request, metadata) {
        return this.rpc.unary(exports.QueryTobinTaxDesc, exports.QueryTobinTaxRequest.fromPartial(request), metadata);
    }
    TobinTaxes(request, metadata) {
        return this.rpc.unary(exports.QueryTobinTaxesDesc, exports.QueryTobinTaxesRequest.fromPartial(request), metadata);
    }
    Actives(request, metadata) {
        return this.rpc.unary(exports.QueryActivesDesc, exports.QueryActivesRequest.fromPartial(request), metadata);
    }
    VoteTargets(request, metadata) {
        return this.rpc.unary(exports.QueryVoteTargetsDesc, exports.QueryVoteTargetsRequest.fromPartial(request), metadata);
    }
    FeederDelegation(request, metadata) {
        return this.rpc.unary(exports.QueryFeederDelegationDesc, exports.QueryFeederDelegationRequest.fromPartial(request), metadata);
    }
    MissCounter(request, metadata) {
        return this.rpc.unary(exports.QueryMissCounterDesc, exports.QueryMissCounterRequest.fromPartial(request), metadata);
    }
    AggregatePrevote(request, metadata) {
        return this.rpc.unary(exports.QueryAggregatePrevoteDesc, exports.QueryAggregatePrevoteRequest.fromPartial(request), metadata);
    }
    AggregatePrevotes(request, metadata) {
        return this.rpc.unary(exports.QueryAggregatePrevotesDesc, exports.QueryAggregatePrevotesRequest.fromPartial(request), metadata);
    }
    AggregateVote(request, metadata) {
        return this.rpc.unary(exports.QueryAggregateVoteDesc, exports.QueryAggregateVoteRequest.fromPartial(request), metadata);
    }
    AggregateVotes(request, metadata) {
        return this.rpc.unary(exports.QueryAggregateVotesDesc, exports.QueryAggregateVotesRequest.fromPartial(request), metadata);
    }
    Params(request, metadata) {
        return this.rpc.unary(exports.QueryParamsDesc, exports.QueryParamsRequest.fromPartial(request), metadata);
    }
}
exports.QueryClientImpl = QueryClientImpl;
exports.QueryDesc = {
    serviceName: "terra.oracle.v1beta1.Query",
};
exports.QueryExchangeRateDesc = {
    methodName: "ExchangeRate",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryExchangeRateRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryExchangeRateResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryExchangeRatesDesc = {
    methodName: "ExchangeRates",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryExchangeRatesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryExchangeRatesResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryTobinTaxDesc = {
    methodName: "TobinTax",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryTobinTaxRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryTobinTaxResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryTobinTaxesDesc = {
    methodName: "TobinTaxes",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryTobinTaxesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryTobinTaxesResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryActivesDesc = {
    methodName: "Actives",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryActivesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryActivesResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryVoteTargetsDesc = {
    methodName: "VoteTargets",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryVoteTargetsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryVoteTargetsResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryFeederDelegationDesc = {
    methodName: "FeederDelegation",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryFeederDelegationRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryFeederDelegationResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryMissCounterDesc = {
    methodName: "MissCounter",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryMissCounterRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryMissCounterResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryAggregatePrevoteDesc = {
    methodName: "AggregatePrevote",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryAggregatePrevoteRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryAggregatePrevoteResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryAggregatePrevotesDesc = {
    methodName: "AggregatePrevotes",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryAggregatePrevotesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryAggregatePrevotesResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryAggregateVoteDesc = {
    methodName: "AggregateVote",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryAggregateVoteRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryAggregateVoteResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryAggregateVotesDesc = {
    methodName: "AggregateVotes",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryAggregateVotesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryAggregateVotesResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.QueryParamsDesc = {
    methodName: "Params",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryParamsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.QueryParamsResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
class GrpcWebImpl {
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        var _a;
        const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new browser_headers_1.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap))
            : metadata || this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc_web_1.grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata,
                transport: this.options.transport,
                debug: this.options.debug,
                onEnd: function (response) {
                    if (response.status === grpc_web_1.grpc.Code.OK) {
                        resolve(response.message);
                    }
                    else {
                        const err = new Error(response.statusMessage);
                        err.code = response.status;
                        err.metadata = response.trailers;
                        reject(err);
                    }
                },
            });
        });
    }
}
exports.GrpcWebImpl = GrpcWebImpl;
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=query.js.map