import { Network } from "@ethersproject/networks";
import { DeliverTxResponse, SigningStargateClientOptions } from "@cosmjs/stargate";
import { OfflineSigner } from "@cosmjs/proto-signing";
import { LogDescription } from "ethers/lib/utils";
import { ContractReceipt, ethers } from "ethers";
export declare enum Environment {
    DEVNET = "devnet",
    TESTNET = "testnet",
    MAINNET = "mainnet"
}
export declare enum EvmChain {
    ETHEREUM = "ethereum",
    AVALANCHE = "avalanche",
    FANTOM = "fantom",
    POLYGON = "polygon",
    MOONBEAM = "moonbeam"
}
export declare enum CosmosChain {
    AXELAR = "axelar",
    COSMOSHUB = "cosmoshub",
    JUNO = "juno",
    OSMOSIS = "osmosis",
    TERRA = "terra"
}
export interface SendTokenArgs {
    destinationChain: EvmChain | CosmosChain;
    destinationAddress: string;
    symbol: string;
    amount: string;
}
export interface ApproveTxArgs {
    tokenAddress: string;
    amount?: string;
}
export interface CallContractTxArgs {
    destinationChain: EvmChain | CosmosChain;
    destinationContractAddress: string;
    payload: string;
}
export interface CallContractWithTokenTxArgs extends CallContractTxArgs {
    symbol: string;
    amount: string;
}
export interface TxOption {
    gasLimit?: string;
    gasPrice?: string;
    maxFeePerGas: string;
    maxPriorityFeePerGas: string;
}
export declare type AxelarAssetTransferConfig = {
    environment: Environment;
    auth?: "local" | "metamask";
    overwriteResourceUrl?: string;
};
export declare type AxelarQueryAPIConfig = {
    axelarRpcUrl?: string;
    axelarLcdUrl?: string;
    environment: Environment;
};
export declare type CosmosBasedWalletDetails = {
    mnemonic?: string;
    offlineSigner?: OfflineSigner;
};
export declare type EvmWalletDetails = {
    privateKey?: string;
    useWindowEthereum?: boolean;
    provider?: ethers.providers.JsonRpcProvider;
};
export interface AxelarQueryClientConfig {
    axelarRpcUrl?: string;
    environment: Environment;
}
export interface EVMClientConfig {
    rpcUrl: string;
    networkOptions?: Network;
    evmWalletDetails: EvmWalletDetails;
}
export interface AxelarSigningClientConfig extends AxelarQueryClientConfig {
    cosmosBasedWalletDetails: CosmosBasedWalletDetails;
    options: SigningStargateClientOptions;
}
export declare type AxelarRecoveryAPIConfig = {
    environment: Environment;
};
export interface FeeInfoResponse {
    fee_info: {
        chain: string;
        asset: string;
        fee_rate: string;
        min_fee: string;
        max_fee: string;
    };
}
export interface TransferFeeResponse {
    fee: {
        denom: string;
        amount: string;
    };
}
export declare enum GasToken {
    ETH = "ETH",
    AVAX = "AVAX",
    GLMR = "GLMR",
    FTM = "FTM",
    MATIC = "MATIC",
    UST = "UST",
    USDC = "USDC"
}
export interface AddGasOptions {
    amount?: string;
    refundAddress?: string;
    estimatedGasUsed?: number;
    evmWalletDetails?: EvmWalletDetails;
}
export interface EventLog {
    signature: string;
    eventLog: LogDescription;
    logIndex: number;
}
export interface ExecuteArgs {
    commandId: string;
    sourceChain: string;
    sourceAddress: string;
    payload: string;
    symbol?: string;
    amount?: string;
}
export interface TxResult {
    success: boolean;
    transaction?: ContractReceipt;
    error?: string;
    data?: {
        functionName: string;
        args: ExecuteArgs;
    };
}
export interface QueryGasFeeOptions {
    provider?: ethers.providers.JsonRpcProvider;
    estimatedGas?: number;
}
export interface AxelarTxResponse extends DeliverTxResponse {
    rawLog: any;
}
export declare enum ApproveGatewayError {
    ALREADY_APPROVED = "already approved",
    ALREADY_EXECUTED = "already executed",
    SIGN_COMMAND_FAILED = "cannot sign command",
    FETCHING_STATUS_FAILED = "cannot fetching status",
    ERROR_BATCHED_COMMAND = "cannot find batch command",
    ERROR_UNKNOWN = "unknown error",
    ERROR_ACCOUNT_SEQUENCE_MISMATCH = "account sequence mismatch"
}
export interface ApproveGatewayResponse {
    success: boolean;
    error?: ApproveGatewayError | string;
    confirmTx?: AxelarTxResponse;
    createPendingTransferTx?: AxelarTxResponse;
    signCommandTx?: AxelarTxResponse;
    approveTx?: any;
}
//# sourceMappingURL=index.d.ts.map