"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const AxelarQueryAPI_1 = require("../AxelarQueryAPI");
const types_1 = require("../types");
describe("AxelarQueryAPI", () => {
    const api = new AxelarQueryAPI_1.AxelarQueryAPI({ environment: types_1.Environment.TESTNET });
    beforeEach(() => {
        jest.clearAllMocks();
    });
    describe("getFeeForChainAndAsset", () => {
        test("It should generate a fee response", () => __awaiter(void 0, void 0, void 0, function* () {
            const [chain, assetDenom] = ["avalanche", "uusd"];
            const response = yield api.getFeeForChainAndAsset(chain, assetDenom);
            expect(response.fee_info).toBeDefined();
            expect(response.fee_info.chain).toEqual(chain);
            expect(response.fee_info.asset).toEqual(assetDenom);
            expect(response.fee_info.fee_rate).toBeDefined();
            expect(response.fee_info.min_fee).toBeDefined();
            expect(response.fee_info.max_fee).toBeDefined();
        }));
    });
    describe("getTransferFee", () => {
        test("It should generate a transfer fee for a specific transaction", () => __awaiter(void 0, void 0, void 0, function* () {
            const [sourceChainName, destinationChainName, assetDenom, amount] = [
                "avalanche",
                "polygon",
                "uusd",
                100000000,
            ];
            const response = yield api.getTransferFee(sourceChainName, destinationChainName, assetDenom, amount);
            expect(response).toBeDefined();
            expect(response.fee).toBeDefined();
            expect(response.fee.denom).toEqual(assetDenom);
            expect(response.fee.amount).toBeDefined();
        }));
    });
    describe("getGasPrice", () => {
        test("It should get a gas price", () => __awaiter(void 0, void 0, void 0, function* () {
            const [sourceChainName, destinationChainName, sourceChainTokenSymbol] = [
                types_1.EvmChain.AVALANCHE,
                types_1.EvmChain.FANTOM,
                types_1.GasToken.AVAX,
            ];
            const response = yield api.getGasInfo(sourceChainName, destinationChainName, sourceChainTokenSymbol);
            expect(response.source_token).toBeDefined();
            expect(response.destination_native_token).toBeDefined();
        }));
        test("It should return estimated gas amount", () => __awaiter(void 0, void 0, void 0, function* () {
            const gasAmount = yield api.estimateGasFee(types_1.EvmChain.AVALANCHE, types_1.EvmChain.ETHEREUM, types_1.GasToken.AVAX);
            expect(gasAmount).toBeDefined();
        }));
    });
    xdescribe("getDenomFromSymbol", () => {
        test("It should get the denom for an asset given its symbol on a chain", () => __awaiter(void 0, void 0, void 0, function* () {
            const response = yield api.getDenomFromSymbol("UST", "ethereum");
            expect(response).toEqual("uusd");
        }));
    });
    xdescribe("getSymbolFromDenom", () => {
        test("It should get the symbol for an asset on a given chain given its denom", () => __awaiter(void 0, void 0, void 0, function* () {
            const response = yield api.getSymbolFromDenom("uusd", "ethereum");
            expect(response).toEqual("UST");
        }));
    });
});
//# sourceMappingURL=AxelarQueryAPI.spec.js.map