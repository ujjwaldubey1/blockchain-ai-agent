"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("../..");
const AxelarAssetTransfer_1 = require("../AxelarAssetTransfer");
const types_1 = require("../types");
const stubs_1 = require("./stubs");
describe("AxelarAssetTransfer", () => {
    const socket = {
        joinRoomAndWaitForEvent: jest.fn(),
    };
    beforeEach(() => {
        jest
            .spyOn(AxelarAssetTransfer_1.AxelarAssetTransfer.prototype, "getSocketService")
            .mockReturnValueOnce(socket);
        jest.clearAllMocks();
    });
    describe("on init", () => {
        let bridge;
        beforeEach(() => {
            bridge = new AxelarAssetTransfer_1.AxelarAssetTransfer({
                environment: types_1.Environment.TESTNET,
            });
        });
        describe("AxelarAssetTransfer", () => {
            it("should be defined", () => {
                expect(bridge).toBeDefined();
            });
            it("should have environment", () => {
                expect(bridge.environment).toBeTruthy();
            });
            it("should have resource url", () => {
                expect(bridge.resourceUrl).toBeTruthy();
            });
        });
        describe("RestService", () => {
            it("should be defined", () => {
                expect(bridge.api).toBeDefined();
            });
        });
        describe("SocketService", () => {
            it("should be defined", () => {
                expect(socket).toBeDefined();
            });
        });
    });
    describe("getOneTimeCode()", () => {
        let bridge;
        beforeEach(() => {
            bridge = new AxelarAssetTransfer_1.AxelarAssetTransfer({
                environment: types_1.Environment.TESTNET,
            });
        });
        describe("on error", () => {
            describe("when called", () => {
                let otc;
                let error;
                beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
                    jest.spyOn(bridge.api, "get").mockRejectedValue((0, stubs_1.apiErrorStub)());
                    otc = yield bridge.getOneTimeCode((0, stubs_1.ethAddressStub)(), (0, stubs_1.uuidStub)()).catch((_error) => {
                        error = _error;
                    });
                }));
                describe("api", () => {
                    it("should be called", () => {
                        expect(bridge.api.get).toHaveBeenCalledWith(`${__1.CLIENT_API_GET_OTC}?publicAddress=${(0, stubs_1.ethAddressStub)()}`, (0, stubs_1.uuidStub)());
                    });
                });
                describe("getOneTimeCode()", () => {
                    it("shoud not return", () => {
                        expect(otc).toBeUndefined();
                    });
                    it("should throw", () => {
                        expect(error).toEqual((0, stubs_1.apiErrorStub)());
                    });
                });
            });
        });
        describe("on success", () => {
            describe("when called", () => {
                let otc;
                beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
                    jest.spyOn(bridge.api, "get").mockResolvedValue((0, stubs_1.otcStub)());
                    otc = yield bridge.getOneTimeCode((0, stubs_1.ethAddressStub)(), (0, stubs_1.uuidStub)());
                }));
                describe("api", () => {
                    it("should be called", () => {
                        expect(bridge.api.get).toHaveBeenCalledWith(`${__1.CLIENT_API_GET_OTC}?publicAddress=${(0, stubs_1.ethAddressStub)()}`, (0, stubs_1.uuidStub)());
                    });
                });
                describe("getOneTimeCode()", () => {
                    it("shoud return", () => {
                        expect(otc).toEqual((0, stubs_1.otcStub)());
                    });
                });
            });
        });
    });
    describe("getInitRoomId()", () => {
        let bridge;
        beforeEach(() => {
            bridge = new AxelarAssetTransfer_1.AxelarAssetTransfer({
                environment: types_1.Environment.TESTNET,
            });
        });
        describe("on error", () => {
            describe("when called", () => {
                let roomId;
                let error;
                beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
                    jest.spyOn(bridge.api, "post").mockRejectedValue((0, stubs_1.apiErrorStub)());
                    const dto = (0, stubs_1.depositAddressPayloadStub)();
                    roomId = yield bridge
                        .getInitRoomId(dto.fromChain, dto.toChain, dto.destinationAddress, dto.asset, dto.publicAddress, dto.signature, (0, stubs_1.uuidStub)())
                        .catch((_error) => {
                        error = _error;
                    });
                }));
                describe("api", () => {
                    it("should be called", () => {
                        expect(bridge.api.post).toHaveBeenCalledWith(__1.CLIENT_API_POST_TRANSFER_ASSET, (0, stubs_1.depositAddressPayloadStub)(), (0, stubs_1.uuidStub)());
                    });
                });
                describe("getInitRoomId()", () => {
                    it("should throw", () => {
                        expect(error).toEqual((0, stubs_1.apiErrorStub)());
                    });
                    it("shoud return", () => {
                        expect(roomId).toBeUndefined();
                    });
                });
            });
        });
        describe("on success", () => {
            describe("when called", () => {
                let roomId;
                beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
                    jest.spyOn(bridge.api, "post").mockResolvedValue({
                        data: (0, stubs_1.roomIdStub)(),
                    });
                    const dto = (0, stubs_1.depositAddressPayloadStub)();
                    roomId = yield bridge.getInitRoomId(dto.fromChain, dto.toChain, dto.destinationAddress, dto.asset, dto.publicAddress, dto.signature, (0, stubs_1.uuidStub)());
                }));
                describe("api", () => {
                    it("should be called", () => {
                        expect(bridge.api.post).toHaveBeenCalledWith(__1.CLIENT_API_POST_TRANSFER_ASSET, (0, stubs_1.depositAddressPayloadStub)(), (0, stubs_1.uuidStub)());
                    });
                });
                describe("getInitRoomId()", () => {
                    it("shoud return", () => {
                        expect(roomId).toBe((0, stubs_1.roomIdStub)().roomId);
                    });
                });
            });
        });
    });
    describe("getLinkEvent()", () => {
        let bridge;
        beforeEach(() => {
            bridge = new AxelarAssetTransfer_1.AxelarAssetTransfer({
                environment: types_1.Environment.TESTNET,
            });
        });
        describe("on error", () => {
            describe("when called", () => {
                let roomId;
                let error;
                beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
                    jest.spyOn(socket, "joinRoomAndWaitForEvent").mockRejectedValue((0, stubs_1.apiErrorStub)());
                    roomId = yield bridge.getLinkEvent((0, stubs_1.roomIdStub)().roomId).catch((_error) => {
                        error = _error;
                    });
                }));
                describe("api", () => {
                    it("should be called", () => {
                        expect(socket.joinRoomAndWaitForEvent).toHaveBeenCalledWith((0, stubs_1.roomIdStub)().roomId);
                    });
                });
                describe("getLinkEvent()", () => {
                    it("should throw", () => {
                        expect(error).toEqual((0, stubs_1.apiErrorStub)());
                    });
                    it("shoud return", () => {
                        expect(roomId).toBeUndefined();
                    });
                });
            });
        });
        describe("on success", () => {
            describe("when called", () => {
                let roomId;
                beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
                    jest
                        .spyOn(socket, "joinRoomAndWaitForEvent")
                        .mockResolvedValueOnce({ newRoomId: (0, stubs_1.newRoomIdStub)() });
                    roomId = yield bridge.getLinkEvent((0, stubs_1.roomIdStub)().roomId);
                }));
                describe("api", () => {
                    it("should be called", () => {
                        expect(socket.joinRoomAndWaitForEvent).toHaveBeenCalledWith((0, stubs_1.roomIdStub)().roomId);
                    });
                });
                describe("getInitRoomId()", () => {
                    it("shoud return", () => {
                        expect(roomId).toEqual((0, stubs_1.newRoomIdStub)());
                    });
                });
            });
        });
    });
    describe("getDepositAddress()", () => {
        let bridge;
        beforeEach(() => {
            bridge = new AxelarAssetTransfer_1.AxelarAssetTransfer({
                environment: types_1.Environment.TESTNET,
            });
        });
        describe("when called", () => {
            const fromChain = "terra";
            const toChain = "avalanche";
            const depositAddress = "0xF16DfB26e1FEc993E085092563ECFAEaDa7eD7fD";
            const asset = "uusd";
            let response;
            beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
                jest.spyOn(bridge, "getOneTimeCode").mockResolvedValue((0, stubs_1.otcStub)());
                jest.spyOn(bridge, "getInitRoomId").mockResolvedValue((0, stubs_1.roomIdStub)().roomId);
                jest.spyOn(bridge, "getLinkEvent").mockResolvedValue((0, stubs_1.linkEventStub)().newRoomId);
                response = yield bridge.getDepositAddress(fromChain, toChain, depositAddress, asset);
            }));
            it("should return deposit address", () => {
                expect(response).toBe(JSON.parse((0, stubs_1.newRoomIdStub)())["depositAddress"]);
            });
        });
    });
});
//# sourceMappingURL=AxelarAssetTransfer.spec.js.map