"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var validateDestinationAddress_1 = require("../validateDestinationAddress");
var mock = {
    validateDestinationAddressByChainSymbol: validateDestinationAddress_1.validateDestinationAddressByChainSymbol,
};
describe("validateDestinationAddress() - evm chain", function () {
    beforeEach(function () {
        jest.clearAllMocks();
        jest.spyOn(mock, "validateDestinationAddressByChainSymbol");
    });
    describe("on correct address", function () {
        var chainSymbol = "AVAX";
        var destinationAddress = "0xF16DfB26e1FEc993E085092563ECFAEaDa7eD7fD";
        var environment = "testnet";
        describe("when validateDestinationAddress is called", function () {
            beforeEach(function () {
                mock.validateDestinationAddressByChainSymbol(chainSymbol, destinationAddress, environment);
            });
            test("then it should be called", function () {
                expect(mock.validateDestinationAddressByChainSymbol).toHaveBeenCalledWith(chainSymbol, destinationAddress, environment);
            });
            test("then it should return true", function () {
                expect(mock.validateDestinationAddressByChainSymbol).toHaveReturnedWith(true);
            });
        });
    });
    describe("on wrong address", function () {
        var chainSymbol = "AVAX";
        var destinationAddress = "0xF16DfB26e1FEc993E085092563ECFAEaDa7eD7f";
        var environment = "testnet";
        describe("when validateDestinationAddress is called", function () {
            beforeEach(function () {
                mock.validateDestinationAddressByChainSymbol(chainSymbol, destinationAddress, environment);
            });
            test("then it should be called", function () {
                expect(mock.validateDestinationAddressByChainSymbol).toHaveBeenCalledWith(chainSymbol, destinationAddress, environment);
            });
            test("then it should return false", function () {
                expect(mock.validateDestinationAddressByChainSymbol).toHaveReturnedWith(false);
            });
        });
    });
});
describe("validateDestinationAddress() - cosmos chain", function () {
    beforeEach(function () {
        jest.clearAllMocks();
        jest.spyOn(mock, "validateDestinationAddressByChainSymbol");
    });
    describe("on correct address", function () {
        var chainSymbol = "Terra";
        var destinationAddress = "terra1qem4njhac8azalrav7shvp06myhqldpmkk3p0t";
        var environment = "testnet";
        describe("when validateDestinationAddress is called", function () {
            beforeEach(function () {
                mock.validateDestinationAddressByChainSymbol(chainSymbol, destinationAddress, environment);
            });
            test("then it should be called", function () {
                expect(mock.validateDestinationAddressByChainSymbol).toHaveBeenCalledWith(chainSymbol, destinationAddress, environment);
            });
            test("then it should return true", function () {
                expect(mock.validateDestinationAddressByChainSymbol).toHaveReturnedWith(true);
            });
        });
    });
    describe("on wrong address", function () {
        var chainSymbol = "Terra";
        var destinationAddress = "terra1qem4njhac8azalrav7shvp06myhqldpmkk3p0";
        var environment = "testnet";
        describe("when validateDestinationAddress is called", function () {
            beforeEach(function () {
                mock.validateDestinationAddressByChainSymbol(chainSymbol, destinationAddress, environment);
            });
            test("then it should be called", function () {
                expect(mock.validateDestinationAddressByChainSymbol).toHaveBeenCalledWith(chainSymbol, destinationAddress, environment);
            });
            test("then it should return false", function () {
                expect(mock.validateDestinationAddressByChainSymbol).toHaveReturnedWith(false);
            });
        });
    });
});
//# sourceMappingURL=validateDestinationAddress.spec.js.map